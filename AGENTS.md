# RepoMind — Agent Instructions

## What This Is

RepoMind is an AI memory layer for multi-repo codebases. It provides two ways to consume codebase intelligence:

1. **MCP Server** — An MCP server with 19 structured query tools backed by SQLite. For AI agents that use tool calls (e.g., GitHub Copilot with MCP support).
2. **Flat Files** — Structured JSON and Markdown files generated by the scanner CLI. For AI agents and developers that prefer reading files directly with `grep`, `cat`, `find`.

## Project Structure

```
RepoMind.slnx                              # Solution file (.NET 10 slnx format)
Directory.Build.props                       # Shared: net10.0, nullable, implicit usings

src/
  RepoMind.Mcp/                             # MCP server (STDIO transport)
    Program.cs                              # Entry point, DI, MCP host setup
    Configuration/RepoMindConfiguration.cs  # Config: RootPath, DbPath, MaxParallelism
    Services/
      QueryService.cs                       # SQLite queries against memory DB
      GitService.cs                         # Git operations (pull, status, branch)
      ScannerService.cs                     # In-process scanner invocation
      ProcessRunner.cs                      # IProcessRunner abstraction
    Tools/                                  # MCP tool definitions (10 files)

  RepoMind.Scanner/                         # Roslyn scanner (library + CLI)
    Program.cs                              # Thin CLI wrapper
    ScannerEngine.cs                        # Core scanning logic (callable in-process)
    Models/                                 # ProjectInfo, AssemblyInfo, TypeInfo
    Parsers/                                # CsprojParser, RoslynScanner, ConfigParser
    Writers/                                # SqliteWriter, FlatFileWriter

tests/
  RepoMind.Mcp.Tests/                       # 74 xUnit tests
    TestFixtures/TestDatabaseFixture.cs     # In-memory SQLite with test data
    Services/                               # QueryService, GitService tests
    Tools/                                  # Tool-level tests

memory/                                     # Generated output (not source-controlled)
```

## Build & Test

```bash
dotnet build RepoMind.slnx
dotnet test RepoMind.slnx
```

## Key Conventions

- **Framework:** .NET 10, shared via `Directory.Build.props`
- **Testing:** xUnit + FluentAssertions + NSubstitute
- **MCP SDK:** `ModelContextProtocol` NuGet. Tool classes use `[McpServerToolType]`. Methods use `[McpServerTool(Name=...)]` + `[Description(...)]` (from `System.ComponentModel`).
- **STDIO transport:** stdout is MCP protocol; all logging goes to stderr
- **QueryService testing:** Uses `internal TestConnection` property (requires `InternalsVisibleTo`) to inject shared in-memory SQLite. Connection disposal uses manual `MaybeClose()` pattern (NOT `using var`).
- **Scanner integration:** MCP server references Scanner via ProjectReference. `ScannerService` calls `ScannerEngine.Run()` in-process.
- **Internal package detection:** After scanning all projects, the parser marks package references as "internal" if the package name matches any assembly name found in the scanned codebase. No hardcoded prefixes.

## MCP Tools Provided

| Tool | Description |
|------|-------------|
| `list_projects` | List all scanned projects |
| `get_project_info` | Detailed info for a specific project |
| `get_dependency_graph` | NuGet dependency relationships |
| `search_types` | Find types by name pattern |
| `find_implementors` | Find types implementing an interface |
| `find_type_details` | Full type info (interfaces, DI deps) |
| `search_injections` | Find constructor-injected dependencies |
| `search_endpoints` | Find REST/GraphQL endpoints by route |
| `search_methods` | Find public methods by name pattern |
| `search_config` | Find config keys (appsettings, env vars, IConfiguration) |
| `trace_flow` | Trace type usage chains across projects |
| `analyze_impact` | Blast radius analysis for type changes |
| `get_package_versions` | NuGet package version usage |
| `update_repos` | Git pull all repos (with optional auto-rescan) |
| `get_repo_status` | Git status across all repos |
| `rescan_memory` | Re-run the Roslyn scanner (supports incremental) |
| `generate_agents_md` | Auto-generate AGENTS.md for the codebase |
| `check_version_alignment` | Detect NuGet version mismatches (MAJOR/MINOR) |
| `find_untested_types` | Find production types without test classes |

## Configuration (MCP Server)

The MCP server resolves the target codebase root path via:
1. `REPOMIND_ROOT` environment variable
2. `--root=<path>` CLI argument
3. Current working directory (fallback)

The `memory/` output directory is always `<RootPath>/memory/`.

## Flat File Workflow (No MCP)

For agents or developers that don't use MCP, run the scanner CLI directly:

```bash
# Generate flat files only (no SQLite)
dotnet run --project src/RepoMind.Scanner -- --root /path/to/codebase --flat-only

# Incremental update (only rescan changed projects)
dotnet run --project src/RepoMind.Scanner -- --root /path/to/codebase --flat-only --incremental
```

Output goes to `<root>/memory/`:
- `projects.json` — Project catalog with assemblies and frameworks
- `dependency-graph.json` — Cross-project internal dependency map
- `types-index.json` — All public types with methods, parameters, and endpoints
- `projects/<name>.md` — Per-project detail: assemblies, types, methods, endpoints, config keys

Query examples using CLI tools:
```bash
grep -r "UserService" memory/types-index.json          # Find a type
grep -r "\[GET\]" memory/projects/                      # Find REST endpoints
grep -r "ConnectionString" memory/projects/             # Find config keys
grep -r "implements.*IRepository" memory/projects/      # Find implementors
cat memory/dependency-graph.json                        # View dependency graph
```
